# A6: Integrity constraints. Indexes, triggers, user functions and database populated with data

## 1. Database workload

### 1.1. Estimate of tuples

| Relation Reference | Relation Name        | Order of Magnitude | Estimated Growth   |
| ------------------ | -------------------- | ------------------ | ------------------ |
| R01                | user                 | thousands          | tens per day       |
| R02                | band                 | hundreds           | units per day      |
| R03                | content              | tens of thousands  | hundreds per day   |
| R04                | post                 | tens of thousands  | hundreds per day   |
| R05                | message              | tens of thousands  | hundreds per day   |
| R06                | comment              | thousands          | tens per day       |
| R07                | country              | tens               | no growth expected |
| R08                | city                 | hundreds           | no growth expected |
| R09                | genre                | tens               | no growth expected |
| R10                | skill                | tens               | no growth expected |
| R11                | report               | hundreds           | units per week     |
| R12                | ban                  | tens               | units per month    |
| R13                | notification_trigger | thousands          | tens per day       |
| R14                | user_skill           | thousands          | tens per day       |
| R15                | user_follower        | thousands          | tens per day       |
| R16                | user_rating          | thousands          | tens per day       |
| R17                | user_genre           | thousands          | tens per day       |
| R18                | user_warning         | tens               | units per month    |
| R19                | band_genre           | hundreds           | units per day      |
| R20                | band_membership      | thousands          | units per day      |
| R21                | band_rating          | thousands          | tens per day       |
| R22                | band_warning         | tens               | units per month    |
| R23                | band_follower        | thousands          | tens per day       |
| R24                | band_application     | hundreds           | units per day      |
| R25                | band_invitation      | hundreds           | units per day      |
| R26                | user_notification    | thousands          | tens per day       |

### 1.2. Most frequent queries

| Query Reference | SELECT01 |
| --------------- | -------- |
| Query Description | User Profile |
| Query Frequency | hundreds per day |
```sql
select * from mb_user 
where mb_user.username = $username;
```

| Query Reference | SELECT02 |
| --------------- | -------- |
| Query Description | User Skills for Profile |
| Query Frequency | hundreds per day |
```sql
select * from mb_user
join user_skill
on mb_user.id = user_skill.userId and mb_user.username = $username
join skill
on skill.id = user_skill.skillId;
```

| Query Reference | SELECT03 |
| --------------- | -------- |
| Query Description | Followers |
| Query Frequency | hundreds per day |
```sql
select * from user_follower
join mb_user as users1
on users1.id = user_follower.followingUserId
join mb_user as users2
on user_follower.followedUserId = users2.id
and users2.username = $username;
```

| Query Reference | SELECT04 |
| --------------- | -------- |
| Query Description | Following Users |
| Query Frequency | hundreds per day |
```sql
select * from user_follower
join mb_user as users1
on users1.id = user_follower.followedUserId
join mb_user as users2
on user_follower.followingUserId = users2.id
and users2.username = $username;
```

| Query Reference | SELECT05 |
| --------------- | -------- |
| Query Description | Following Bands |
| Query Frequency | hundreds per day |
```sql
select * from band_follower
join band
on band_follower.bandId = band.id
and band.name = $bandname
join mb_user
on band_follower.userId = mb_user.id;
```

| Query Reference | SELECT06 |
| --------------- | -------- |
| Query Description | Users' Bands |
| Query Frequency | hundreds per day |
```sql
select * from band
join band_membership
on band.id = band_membership.bandId
join mb_user
on mb_user.username = $username and mb_user.id = band_membership.userId;
```

| Query Reference | SELECT07 |
| --------------- | -------- |
| Query Description | Band Profile |
| Query Frequency | hundreds per day |
```sql
select * from band
join band_membership
on band.name = $bandname and band.id = band_membership.bandId
join mb_user
on mb_user.id = band_membership.userId;
```

| Query Reference | SELECT08 |
| --------------- | -------- |
| Query Description | Notifications |
| Query Frequency | tens per day |
```sql
select * from user_notification
join mb_user
on user_notification.userId = mb_user.id
and mb_user.username = $username;
```

| Query Reference | SELECT09 |
| --------------- | -------- |
| Query Description | User Posts |
| Query Frequency | hundreds per day |
```sql
select * from post
join band
on post.bandId = band.id and band.name = $bandname
join mb_user
on post.posterId = mb_user.id and mb_user.username = $username;
```

| Query Reference | SELECT10 |
| --------------- | -------- |
| Query Description | Register |
| Query Frequency | tens per day |
```sql
select *
from mb_user
where mb_user.username = $username;
```

| Query Reference | SELECT11 |
| --------------- | -------- |
| Query Description | Search users/bands |
| Query Frequency | tens per day |
```sql
select * from band 
join band_membership 
on band.id = band_membership.bandId and band.name like %$search_text%
join mb_user
on mb_user.id = band_membership.userId and band.name like %$search_text% or mb_user.username like %$search_text%;
```

| Query Reference | SELECT12 |
| --------------- | -------- |
| Query Description | Feed Page Posts |
| Query Frequency | hundreds per day |
```sql
select * from post
join user_follower
on (post.posterId = user_follower.followedUserId join mb_user on user_follower.followingUserId = mb_user.id and mb_user.username = $username)
join band_follower
on (post.bandId = band_follower.bandId join mb_user on band_follower.userId = mb_user.id and mb_user.username = $username);
```

| Query Reference | SELECT13 |
| --------------- | -------- |
| Query Description | Messages |
| Query Frequency | hundreds per day |
```sql
select * from message
join mb_user a
on message.senderId = a.id and a.username = $username1
join mb_user b
on message.receiverId = b.id and b.username = $username2
join content
on message.contentId = content.id
order by content.date asc;
```

| Query Reference | SELECT14 |
| --------------- | -------- |
| Query Description | All Messages from 1 User |
| Query Frequency | hundreds per day |
```sql
select * from message
join mb_user
on message.senderId = mb_user.id and mb_user.username = $username
order by message.receiverId asc
join content
on message.contentId = content.id
order by content.date asc;
```

| Query Reference | SELECT15 |
| --------------- | -------- |
| Query Description | Reported Content |
| Query Frequency | units per day |
```sql
select * from content
join report
on report.reportedContentId = content.id;
```

| Query Reference | SELECT16 |
| --------------- | -------- |
| Query Description | Admin's User Page |
| Query Frequency | units per day |
```sql
select * from mb_user;
```

| Query Reference | SELECT17 |
| --------------- | -------- |
| Query Description | Admin's Band Page |
| Query Frequency | units per day |
```sql
select * from band;
```

| Query Reference | SELECT18 |
| --------------- | -------- |
| Query Description | Band Posts |
| Query Frequency | hundreds per day |
```sql
select * from post
join band
on post.bandId = band.id and band.name = $bandname;
```


### 1.3. Most frequent modifications


| Query Reference | INSERT01 |
| --------------- | -------- |
| Query Description | Register User |
| Query Frequency | tens per day |
```sql
INSERT INTO user(username, password, name) VALUES($username, $password, $name);
```

| Query Reference | INSERT02 |
| --------------- | -------- |
| Query Description | Create Band |
| Query Frequency | tens per week |
```sql
INSERT INTO band(name, creationDate) VALUES($name, $creationDate);
```

| Query Reference | INSERT03 |
| --------------- | -------- |
| Query Description | Report |
| Query Frequency | units per week |
```sql
INSERT INTO report(text, date, reportTypeID) VALUES($text, $date, $reportTypeID);
```

| Query Reference | INSERT04 |
| --------------- | -------- |
| Query Description | Ban |
| Query Frequency | units per month |
```sql
INSERT INTO ban(reason, banDate, ceaseDate, adminID, bannedID) VALUES($reason, $banDate, $ceaseDate, $adminID, $bannedID);
```

| Query Reference | INSERT05 |
| --------------- | -------- |
| Query Description | Create Post |
| Query Frequency | tens per day |
```sql
INSERT INTO post(contentId,posterId,bandId) VALUES($contentId,$posterId,$bandId);
```

| Query Reference | INSERT06 |
| --------------- | -------- |
| Query Description | Send Message |
| Query Frequency | hundreds per day |
```sql
INSERT INTO message(contentId,senderId,receiverId,bandId) VALUES($contentId,$senderId,$receiverId,$bandId);
```

| Query Reference | DELETE01 |
| --------------- | -------- |
| Query Description | Delete Post |
| Query Frequency | units per month |
```sql
DELETE FROM post WHERE post.id = $id;
```

| Query Reference | DELETE02 |
| --------------- | -------- |
| Query Description | Unfollow User |
| Query Frequency | units per day |
```sql
DELETE FROM user_follower JOIN mb_user ON user_follower.followingUserId = mb_user.id and mb_user.username = $following JOIN mb_user ON user_follower.followedUserId = mb_user.id and mb_user.username = $followed;
```

| Query Reference | DELETE03 |
| --------------- | -------- |
| Query Description | Unfollow Band |
| Query Frequency | units per day |
```sql
DELETE FROM band_follower JOIN band ON band_follower.bandId = band.id and band.name = $bandname JOIN mb_user ON mb_user.id = band_follower.userId and mb_user.username = $username;
```

| Query Reference | UPDATE01 |
| --------------- | -------- |
| Query Description | Change Password |
| Query Frequency | units per month |
```sql
UPDATE mb_user SET mb_user.password = $new_password WHERE mb_user.username = $username;
```

| Query Reference | UPDATE02 |
| --------------- | -------- |
| Query Description | Change Bio |
| Query Frequency | units per month |
```sql
UPDATE mb_user SET mb_user.bio = $new_bio WHERE mb_user.username = $username;
```


## 2. Proposed indexes
### 2.1. Performance Indexes

| Index Reference | IDX01 |
| --------------- | -------- |
| Related Queries | SELECT09 |
| Index Relation | post |
| Index Attribute | posterId |
| Index Type | hash |
| Cardinality | medium |
| Clustering | yes |
| **Justification** | Query SELECT04 searches for a user's posts, having to be fast, since it is used several times; doesn't need range query support; cardinality is medium, so it is a good candidate for clustering. |
```sql
create index user_post on post using hash(posterId);
```
  
| Index Reference | IDX02 |
| --------------- | -------- |
| Related Queries | SELECT01, SELECT03, SELECT04, SELECT06, SELECT13, SELECT14 |
| Index Relation | user |
| Index Attribute | username |
| Index Type | hash |
| Cardinality | high |
| Clustering | no |
| **Justification** | These queries search for users' info/content a lot of times, having to be fast; don't need range query support; cardinality is high, so it is not a good candidate for clustering. |
```sql
create index user_username on user using hash(username);
```

| Index Reference | IDX03 |
| --------------- | -------- |
| Related Queries | SELECT05, SELECT07, SELECT11, SELECT18 |
| Index Relation | band |
| Index Attribute | name |
| Index Type | hash |
| Cardinality | medium |
| Clustering | yes |
| **Justification** | These queries search for bands' info/content a lot of times, having to be fast; don't need range query support; cardinality is medium, so it is a good candidate for clustering. |
```sql
create index band_name on band using hash(name);
```

| Index Reference | IDX04 |
| --------------- | -------- |
| Related Queries | SELECT13, SELECT14 |
| Index Relation | message |
| Index Attribute | senderId |
| Index Type | hash |
| Cardinality | medium |
| Clustering | yes |
| **Justification** | These queries search for users' messages, having to be fast to display the messages at mouse click; don't need range query support; cardinality is medium, so it is a good candidate for clustering. |
```sql
create index message_sender on message using hash(senderId);
```

| Index Reference | IDX05 |
| --------------- | -------- |
| Related Queries | SELECT13, SELECT14 |
| Index Relation | message |
| Index Attribute | senderId |
| Index Type | hash |
| Cardinality | medium |
| Clustering | yes |
| **Justification** | These queries search for users' messages, having to be fast to display the messages at mouse click; don't need range query support; cardinality is medium, so it is a good candidate for clustering. |
```sql
create index message_receiver on message using hash(receiverId);
```

| Index Reference | IDX06 |
| --------------- | -------- |
| Related Queries | SELECT15 |
| Index Relation | report |
| Index Attribute | reportedContentId |
| Index Type | hash |
| Cardinality | medium |
| Clustering | yes |
| **Justification** | Query SELECT15 searches for all reported content; doesn't need range query support; cardinality is medium, so it is a good candidate for clustering. |
```sql
create index report_content on report using hash(reportedContentId);
```

| Index Reference | IDX07 |
| --------------- | -------- |
| Related Queries | SELECT15 |
| Index Relation | report |
| Index Attribute | reportedContentId |
| Index Type | b-tree |
| Cardinality | medium |
| Clustering | no |
| **Justification** | Query SELECT15 searches for all reported content and orders by date; needs range query support; cardinality is medium. |
```sql
create index report_date on report using hash(date);
```

### 2.2. Full-text Search Indexes

| Index Reference | IDX08 |
| --------------- | -------- |
| Related Queries | SELECT11 |
| Index Relation | band |
| Index Attribute | name/description |
| Index Type | gist |
| Cardinality | medium |
| Clustering | yes |
| **Justification** | Optimize the search of a band's name with dynamic data. |
```sql
create index search_band on band using gist((
	setweight(to_tsvector('english', name), 'A') ||
	setweight(to_tsvector('english', description), 'B')
));
```

| Index Reference | IDX09 |
| --------------- | -------- |
| Related Queries | SELECT11 |
| Index Relation | user |
| Index Attribute | username/name/bio |
| Index Type | gist |
| Cardinality | high |
| Clustering | no |
| **Justification** | Optimize the search of a user's username with dynamic data. |
```sql
CREATE INDEX search_user ON mb_user USING GIST ((
	setweight(to_tsvector('english', username), 'A') ||
	setweight(to_tsvector('english', name), 'A') ||
	setweight(to_tsvector('english', bio), 'B')
));
```



## 3. Triggers and Integrity Constraints

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC1                            | Post on behalf of the band or individual post. Post has one field, bandId which denotes if it is a post on behalf of a band. If so, the posterId field must refer to a user who belongs to that band | view below |

```sql 

CREATE FUNCTION check_band_post() RETURNS trigger AS $check_band_post$BEGIN
       
        IF NEW.bandId IS NOT NULL THEN

            IF check_user_belongs_to_band(New.posterId, New.bandId) = FALSE THEN

                RAISE EXCEPTION 'this user does not belong to the band, post not inserted';

            END IF;

        END IF;

    
        RETURN NEW;

    END;
    
$check_band_post$ LANGUAGE plpgsql;

CREATE TRIGGER check_band_post BEFORE INSERT OR UPDATE ON post
    FOR EACH ROW EXECUTE PROCEDURE check_band_post(); 

```
| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC2                            | A ban is either a band ban or user band. To to that, both fields are mutually exclusive  |view below|


```sql

CREATE FUNCTION check_xor_user_band() RETURNS trigger AS $check_xor_user_band$
    BEGIN
        --Check if both user and ban are empty--
        IF NEW.userId IS NULL AND NEW.bandId IS NULL THEN
            RAISE EXCEPTION 'userId and bandId cannot be both null';
        END IF;

        --Check if both are not null
        IF NEW.userId IS NOT NULL AND NEW.bandId IS NOT NULL THEN
            RAISE EXCEPTION 'userId and bandId cannot be both not null (%,%)', NEW.userId, New.bandId;
        END IF;

        RETURN NEW;

    END;

$check_xor_user_band$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_user_band BEFORE INSERT OR UPDATE ON ban
    FOR EACH ROW EXECUTE PROCEDURE check_xor_user_band();


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC3                            | A notification has a type so it is easy to check which is the origin  |view below|

```sql

CREATE TYPE NOTIFICATION_TYPE AS ENUM (
    'user_follower', 'band_follower', 'message', 'comment', 'band_application',
    'band_invitation', 'user_warning', 'band_warning', 'band_invitation_accepted',
    'band_invitation_rejected', 'band_application_accepted', 'band_application_rejected');

CREATE TABLE notification_trigger (

    id SERIAL NOT NULL,
    date TIMESTAMP NOT NULL DEFAULT now(),
    type NOTIFICATION_TYPE NOT NULL,
    originUserFollower INTEGER,
    originBandFollower INTEGER,
    originMessage INTEGER,
    originComment INTEGER,
    originBandApplication INTEGER,
    originBandInvitation INTEGER,
    originUserWarning INTEGER,
    originBandWarning INTEGER
);

```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC4                            | A notification has a type so it has only and only one origin  |view below|

```sql


CREATE FUNCTION check_xor_notification_origin() RETURNS trigger AS $check_xor_notification_origin$
    BEGIN

        --Check for correct type and origin
        IF NEW.type = 'user_follower' AND NEW.originUserFollower IS NULL THEN
            RAISE EXCEPTION 'type user follower without originUserFollowerId';
        END IF;

        IF NEW.type = 'band_follower' AND NEW.originBandFollower IS NULL THEN
            RAISE EXCEPTION 'type band follower without bandFollowerId';
        END IF;

        IF NEW.type = 'message' AND NEW.originMessage IS NULL THEN
            RAISE EXCEPTION 'type message without originMessageId';
        END IF;

        IF NEW.type = 'comment' AND NEW.originComment IS NULL THEN
            RAISE EXCEPTION 'type comment without originCommentId';
        END IF;

        IF NEW.type = 'band_application' AND NEW.originBandApplication IS NULL THEN
            RAISE EXCEPTION 'type band application without originBandApplicationId';
        END IF;

        IF NEW.type = 'band_invitation' AND NEW.originBandInvitation IS NULL THEN
            RAISE EXCEPTION 'type band invitation without band invitation Id';
        END IF;

        IF NEW.type = 'user_warning' AND NEW.originUserWarning IS NULL THEN
            RAISE EXCEPTION 'type user warning without origin user warning id';
        END IF;

        IF NEW.TYPE = 'band_warning' AND NEW.originBandWarning IS NULL THEN
            RAISE EXCEPTION 'type band warning without band warning Id';
        END IF;

        IF NEW.TYPE = 'band_invitation_accepted' AND NEW.originBandInvitation IS NULL THEN
            RAISE EXCEPTION 'type band invitation accepted without band inivitation Id';
        END IF;

         IF NEW.TYPE = 'band_invitation_rejected' AND NEW.originBandInvitation IS NULL THEN
            RAISE EXCEPTION 'type band invitation rejected without band inivitation Id';
        END IF;

        IF NEW.TYPE = 'band_application_accepted' AND NEW.originBandApplication IS NULL THEN
            RAISE EXCEPTION 'type band application accepted without band application Id';
        END IF;

        IF NEW.TYPE = 'band_application_rejected' AND NEW.originBandApplication IS NULL THEN
            RAISE EXCEPTION 'type band application accepted without band application Id';
        END IF;

        RETURN NEW;

    END;
$check_xor_notification_origin$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_notification_origin BEFORE INSERT OR UPDATE ON notification_trigger
    FOR EACH ROW EXECUTE PROCEDURE check_xor_notification_origin();

```
| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC5                            | In a band chat, the sender id has to be a member of the band, so if the destination of a message is a band, the field id must refer to a user which belongs to the band| view below |

```sql

CREATE FUNCTION check_user_belongs_to_band(userIdToCheck Integer, bandIdToCheck Integer) RETURNS BOOLEAN AS $$
    
    DECLARE result BOOLEAN;

    BEGIN
       
        SELECT EXISTS (SELECT band.id FROM band JOIN band_membership ON band.id = band_membership.bandId WHERE band.id = bandIdToCheck AND band_membership.userId = userIdToCheck) INTO result;
        
        RETURN result;

    END;

$$ LANGUAGE plpgsql;


CREATE FUNCTION check_band_message() RETURNS trigger AS $check_band_message$
    BEGIN
       
        IF NEW.bandId IS NOT NULL THEN

            IF check_user_belongs_to_band(New.senderId, New.bandId) = FALSE THEN

                RAISE EXCEPTION 'this user does not belong to the band';

            END IF;

        END IF;

    
        RETURN NEW;

    END;

$check_band_message$ LANGUAGE plpgsql;

CREATE TRIGGER check_band_message BEFORE INSERT OR UPDATE ON message
    FOR EACH ROW EXECUTE PROCEDURE check_band_message();

```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC6                            | A message destination is either a band or a user, they are mutually exclusive| view below |

```sql

CREATE FUNCTION check_xor_message_destination() RETURNS trigger AS $check_xor_message_destination$
    BEGIN
        
        IF NEW.receiverId IS NULL AND NEW.bandId IS NULL THEN
            RAISE EXCEPTION 'receiverId and bandId cannot be both null';
        END IF;

        IF NEW.receiverId IS NOT NULL AND NEW.bandId IS NOT NULL THEN
            RAISE EXCEPTION 'receiverId and bandId cannot be both not null (%,%)', NEW.receiverId, New.bandId;
        END IF;

        RETURN NEW;

    END;
$check_xor_message_destination$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_message_destination BEFORE INSERT OR UPDATE ON message
    FOR EACH ROW EXECUTE PROCEDURE check_xor_message_destination();


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC7                            | A report has a type so it is clearly identified who or what is being reported| view below |

```sql

CREATE TYPE REPORT_TYPE AS ENUM ('user_report', 'band_report', 'content_report');

CREATE TABLE report (

    id SERIAL NOT NULL,
    text TEXT NOT NULL,
    date TIMESTAMP DEFAULT now(),
    reportType REPORT_TYPE NOT NULL,
    reportedContentId INTEGER,
    reportedUserId INTEGER,
    reportedBandId INTEGER,
    reporterUserId INTEGER
);


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC8                           | A report has a type so the origin of the report is only one | view below |

```sql

CREATE FUNCTION check_xor_report_type() RETURNS trigger AS $check_xor_report_type$
    BEGIN
        --Check for correct type
        IF NEW.reportType = 'user_report' AND NEW.reportedUserId IS NULL THEN
            RAISE EXCEPTION 'type user_report without reportedUserId';
        END IF;

        IF NEW.reportType = 'band_report' AND NEW.reportedBandId IS NULL THEN
            RAISE EXCEPTION 'type user_report without reportedBandId';
        END IF;

        IF NEW.reportType = 'content_report' AND NEW.reporterUserId IS NULL THEN
            RAISE EXCEPTION 'type user_report without reporterUserId';
        END IF;

        RETURN NEW;

    END;
$check_xor_report_type$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_report_type BEFORE INSERT OR UPDATE ON report
    FOR EACH ROW EXECUTE PROCEDURE check_xor_report_type();


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC9                           | A band invitation has 4 identified types of status | view below |

```sql

CREATE TYPE BAND_INVITATION_STATUS AS ENUM ('canceled', 'pending', 'accepted', 'rejected');

CREATE TABLE band_invitation(

    id SERIAL NOT NULL,
    userId INTEGER NOT NULL,
    bandId INTEGER NOT NULL,
    date TIMESTAMP DEFAULT now(),
    lastStatusDate DATE,
    status BAND_INVITATION_STATUS DEFAULT 'pending'

);

```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC10                           | A band application has 4 identified types of status | view below |

```sql

CREATE TYPE BAND_APPLICATION_STATUS AS ENUM ('canceled', 'pending', 'accepted', 'rejected');

CREATE TABLE band_application (

    id SERIAL NOT NULL,
    userId INTEGER NOT NULL,
    bandId INTEGER NOT NULL,
    date TIMESTAMP DEFAULT now(),
    lastStatusDate DATE,
    status BAND_APPLICATION_STATUS DEFAULT 'pending'

);

```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC11                           | Only an admin can insert or update a skill | view below |

```sql

CREATE FUNCTION is_admin (userId INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    isAdmin BOOLEAN;
BEGIN
   SELECT mb_user.admin INTO isAdmin FROM mb_user WHERE mb_user.id = userId;

   RETURN isAdmin;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION check_is_admin_skill() RETURNS trigger AS $check_is_admin_skill$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.creatingAdminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_skill$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_skill BEFORE INSERT OR UPDATE ON skill
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_skill();

```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC12                           | Only an admin can insert or update a genre | view below |

```sql

CREATE FUNCTION is_admin (userId INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    isAdmin BOOLEAN;
BEGIN
   SELECT mb_user.admin INTO isAdmin FROM mb_user WHERE mb_user.id = userId;

   RETURN isAdmin;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION check_is_admin_genre() RETURNS trigger AS $check_is_admin_genre$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.creatingAdminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_genre$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_genre BEFORE INSERT OR UPDATE ON genre
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_genre();


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC13                           | Only an admin can insert or update a ban | view below |

```sql

CREATE FUNCTION is_admin (userId INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    isAdmin BOOLEAN;
BEGIN
   SELECT mb_user.admin INTO isAdmin FROM mb_user WHERE mb_user.id = userId;

   RETURN isAdmin;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION check_is_admin_ban() RETURNS trigger AS $check_is_admin_ban$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.adminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_ban$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_ban BEFORE INSERT OR UPDATE ON ban
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_ban();


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC14                           | Only an admin can warn a user | view below |

```sql

CREATE FUNCTION is_admin (userId INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    isAdmin BOOLEAN;
BEGIN
   SELECT mb_user.admin INTO isAdmin FROM mb_user WHERE mb_user.id = userId;

   RETURN isAdmin;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION check_is_admin_user_warning() RETURNS trigger AS $check_is_admin_user_warning$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.adminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_user_warning$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_user_warning BEFORE INSERT OR UPDATE ON user_warning
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_user_warning();


```

| Integrity Constraint Reference | Integrity Description                                                                                                                                                                                | SQL Code   |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| IC15                           | Only an admin can warn a band | view below |

```sql

CREATE FUNCTION is_admin (userId INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    isAdmin BOOLEAN;
BEGIN
   SELECT mb_user.admin INTO isAdmin FROM mb_user WHERE mb_user.id = userId;

   RETURN isAdmin;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION check_is_admin_band_warning() RETURNS trigger AS $check_is_admin_band_warning$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.adminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_band_warning$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_band_warning BEFORE INSERT OR UPDATE ON band_warning
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_band_warning();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER01         | When a user starts following another user the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE FUNCTION insert_notification_trigger_user_follower() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originUserFollower) VALUES('user_follower',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_user_follower AFTER INSERT ON user_follower
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_user_follower();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER02         | When a user starts following a band, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE FUNCTION insert_notification_trigger_band_follower() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandFollower) VALUES('band_follower',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_follower AFTER INSERT ON band_follower
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_follower();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER03         | When a user sends a message, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE FUNCTION insert_notification_trigger_message() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originMessage) VALUES('message',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_message AFTER INSERT ON message
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_message();

```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER04         | When a user comment a post, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_comment() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originComment) VALUES('comment',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_comment AFTER INSERT ON comment
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_comment();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER05         | When a user apply to a band, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |


```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_application() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandApplication) VALUES('band_application',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_application AFTER INSERT ON band_application
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_application();

```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER06         | When a member of the band reply to a band application, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_application_accepted() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'accepted' THEN
            INSERT INTO notification_trigger(type,originBandApplication) VALUES('band_application_accepted',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_application_accepted AFTER UPDATE ON band_application
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_application_accepted();

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_application_rejected() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'rejected' THEN
            INSERT INTO notification_trigger(type,originBandApplication) VALUES('band_application_rejected',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_application_rejected AFTER UPDATE ON band_application
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_application_rejected();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER07         | When a band invites a user, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_invitation() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandInvitation) VALUES('band_invitation',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_invitation AFTER INSERT ON band_invitation
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_invitation();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER08         | When a user replies to a band invitation, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_invitation_accepted() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'accepted' THEN
            INSERT INTO notification_trigger(type,originBandInvitation) VALUES('band_invitation_accepted',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_invitation_accepted AFTER UPDATE ON band_invitation
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_invitation_accepted();

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_invitation_rejected() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'rejected' THEN
            INSERT INTO notification_trigger(type,originBandInvitation) VALUES('band_invitation_rejected',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_invitation_rejected AFTER UPDATE ON band_invitation
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_invitation_rejected();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER09         | When an admin warns a user, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |

```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_user_warning() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originUserWarning) VALUES('user_warning',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_user_warning AFTER INSERT ON user_warning
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_user_warning();


```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER10         | When an admin warns a band, the database triggers a new row in the notification_trigger table so the notification trigger can further generate the the needed user_notifications                    | see below    |


```sql

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_warning() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandWarning) VALUES('band_warning',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_warning AFTER INSERT ON band_warning
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_warning();

```

| Trigger Reference | Trigger Description | SQL Code |
| ----------------- | ------------------- | -------- |
| TRIGGER11         | When a new row is added to the notification_trigger table, a trigger is generated to insert rows in the user_notification table according to the type of notification_trigger                    | see below (check sql code of insert auxiliary functions in 4. Código SQL)    |

```sql
CREATE OR REPLACE FUNCTION trigger_user_notifications() RETURNS TRIGGER AS $$
    BEGIN
        CASE New.type
            WHEN 'user_follower' THEN
                PERFORM insert_user_notifications_user_follower(New.id, New.originUserFollower);
            WHEN 'band_follower' THEN
                PERFORM insert_user_notifications_band_follower(New.id, New.originBandFollower);
            WHEN 'message' THEN
                PERFORM insert_user_notifications_message(New.id, New.originMessage);
            WHEN 'comment' THEN
                PERFORM insert_user_notifications_comment(New.id, New.originComment);
            ELSE
                RAISE EXCEPTION 'Notification type invalid';
        END CASE;

        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_user_notifications AFTER INSERT ON notification_trigger
    FOR EACH ROW EXECUTE PROCEDURE trigger_user_notifications();
```

## 4. Código SQL
```sql
    \c lbaw1712;


DROP TRIGGER IF EXISTS insert_notification_trigger_user_follower ON user_follower;
DROP FUNCTION  IF EXISTS insert_notification_trigger_user_follower();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_follower ON band_follower;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_follower();

DROP TRIGGER IF EXISTS insert_notification_trigger_message ON message;
DROP FUNCTION  IF EXISTS insert_notification_trigger_message();

DROP TRIGGER IF EXISTS insert_notification_trigger_comment ON comment;
DROP FUNCTION  IF EXISTS insert_notification_trigger_comment();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_application ON band_application;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_application();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_invitation ON band_invitation;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_invitation();

DROP TRIGGER IF EXISTS insert_notification_trigger_user_warning ON user_warning;
DROP FUNCTION  IF EXISTS insert_notification_trigger_user_warning();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_warning ON band_warning;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_warning();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_invitation_rejected ON band_invitation;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_invitation_rejected();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_invitation_accepted ON band_invitation;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_invitation_accepted();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_application_rejected ON band_application;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_application_rejected();

DROP TRIGGER IF EXISTS insert_notification_trigger_band_application_accepted ON band_application;
DROP FUNCTION  IF EXISTS insert_notification_trigger_band_application_accepted();



DROP TABLE IF EXISTS user_notification CASCADE;
DROP TRIGGER IF EXISTS check_xor_notification_origin ON notification_trigger;
DROP FUNCTION  IF EXISTS check_xor_notification_origin();
DROP TABLE IF EXISTS notification_trigger CASCADE;
DROP TYPE IF EXISTS NOTIFICATION_TYPE;

DROP TABLE IF EXISTS band_invitation CASCADE;
DROP TYPE IF EXISTS BAND_INVITATION_STATUS;
DROP TABLE IF EXISTS band_application CASCADE;
DROP TYPE IF EXISTS BAND_APPLICATION_STATUS;
--DROP TRIGGER IF EXISTS insert_notification_trigger_band_follower ON band_follower;
--DROP FUNCTION  IF EXISTS insert_notification_trigger_band_follower();
DROP TABLE IF EXISTS band_follower CASCADE;
DROP TRIGGER IF EXISTS check_is_admin_band_warning ON band_warning;
DROP FUNCTION  IF EXISTS check_is_admin_band_warning();
DROP TABLE IF EXISTS band_warning CASCADE;
DROP TABLE IF EXISTS band_rating CASCADE;
DROP TABLE IF EXISTS band_membership CASCADE;
DROP TABLE IF EXISTS band_genre CASCADE;

DROP TRIGGER IF EXISTS check_is_admin_user_warning ON user_warning;
DROP FUNCTION  IF EXISTS check_is_admin_user_warning();
DROP TABLE IF EXISTS user_warning CASCADE;
DROP TABLE IF EXISTS user_rating CASCADE;
-- DROP TRIGGER IF EXISTS insert_notification_trigger_user_follower ON user_follower;
-- DROP FUNCTION  IF EXISTS insert_notification_trigger_user_follower();
DROP TABLE IF EXISTS user_follower CASCADE;
DROP TABLE IF EXISTS user_skill CASCADE;
DROP TRIGGER IF EXISTS check_xor_user_band ON ban;
DROP FUNCTION  IF EXISTS check_xor_user_band();

DROP TRIGGER IF EXISTS check_is_admin_ban ON ban;
DROP FUNCTION  IF EXISTS check_is_admin_ban();
DROP TABLE IF EXISTS ban CASCADE;

DROP TRIGGER IF EXISTS check_xor_report_type ON report;
DROP FUNCTION  IF EXISTS check_xor_report_type();
DROP TABLE IF EXISTS report CASCADE;
DROP TYPE IF EXISTS REPORT_TYPE;

DROP TRIGGER IF EXISTS check_is_admin_skill ON skill;
DROP FUNCTION  IF EXISTS check_is_admin_skill();
DROP TABLE IF EXISTS skill CASCADE;

DROP TRIGGER IF EXISTS check_is_admin_genre ON genre;
DROP FUNCTION  IF EXISTS check_is_admin_genre();
DROP TABLE IF EXISTS genre CASCADE;

DROP TABLE IF EXISTS comment CASCADE;

DROP TRIGGER IF EXISTS check_xor_message_destination ON message;
DROP FUNCTION  IF EXISTS check_xor_message_destination();
DROP TRIGGER IF EXISTS check_band_message ON message;
DROP FUNCTION  IF EXISTS check_band_message();
DROP FUNCTION IF EXISTS check_user_belongs_to_band(userId Integer, bandId Integer);
DROP TABLE IF EXISTS message CASCADE;

DROP TRIGGER IF EXISTS check_band_post ON post;
DROP FUNCTION  IF EXISTS check_band_post();
DROP TABLE IF EXISTS post CASCADE;

DROP TABLE IF EXISTS content CASCADE;
DROP TABLE IF EXISTS band CASCADE;
DROP FUNCTION  IF EXISTS is_admin(userId INTEGER);
DROP TABLE IF EXISTS mb_user CASCADE;

DROP TABLE IF EXISTS city CASCADE;
DROP TABLE IF EXISTS country CASCADE;


/*****************************************************/
/****************** Country **************************/
/*****************************************************/


CREATE TABLE country (
    id SERIAL NOT NULL,
    name TEXT NOT NULL
);

ALTER TABLE ONLY country
    ADD CONSTRAINT country_pkey PRIMARY KEY (id);


/*****************************************************/
/****************** City *****************************/
/*****************************************************/



CREATE TABLE city (
    id SERIAL NOT NULL,
    name TEXT NOT NULL,
    countryId INTEGER NOT NULL
);

ALTER TABLE ONLY city
    ADD CONSTRAINT city_pkey PRIMARY KEY (id);

ALTER TABLE ONLY city
    ADD CONSTRAINT city_country_id_fkey FOREIGN KEY (countryId) REFERENCES country(id) ON UPDATE CASCADE;

-- \i db/insertLocations.sql;

/*****************************************************/
/***************** User ******************************/
/*****************************************************/



CREATE TABLE mb_user (

    id SERIAL NOT NULL,
    username TEXT NOT NULL,
    password TEXT NOT NULL,
    name TEXT NOT NULL,
    bio TEXT,
    dateOfBirth DATE,
    deactivationDate DATE,
    warns INTEGER DEFAULT 0,
    location INTEGER,
    rating REAL,
    admin BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE ONLY mb_user
    ADD CONSTRAINT mb_user_pkey PRIMARY KEY (id);

ALTER TABLE ONLY mb_user
    ADD CONSTRAINT mb_user_username_unique UNIQUE (username);

ALTER TABLE ONLY mb_user
    ADD CONSTRAINT mb_user_dateOfBirth_past CHECK (dateOfBirth < now());

ALTER TABLE ONLY mb_user
    ADD CONSTRAINT mb_user_location_fkey FOREIGN KEY (location) REFERENCES city(id) ON UPDATE CASCADE;

ALTER TABLE ONLY mb_user
    ADD CONSTRAINT mb_user_rating_domain CHECK ((rating <= 5.0) AND (rating >= 0.0));


CREATE FUNCTION is_admin (userId INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    isAdmin BOOLEAN;
BEGIN
   SELECT mb_user.admin INTO isAdmin FROM mb_user WHERE mb_user.id = userId;

   RETURN isAdmin;
END;
$$ LANGUAGE plpgsql;

/*****************************************************/
/***************** Band ******************************/
/*****************************************************/



CREATE TABLE band (

    id SERIAL NOT NULL,
    name char(50) NOT NULL,
    creationDate DATE DEFAULT now(),
    ceaseDate DATE,
    location INTEGER,
    isActive BOOLEAN DEFAULT TRUE
);

ALTER TABLE ONLY band
    ADD CONSTRAINT band_pkey PRIMARY KEY (id);

ALTER TABLE ONLY band
    ADD CONSTRAINT band_name_unique UNIQUE (name);

ALTER TABLE ONLY band
    ADD CONSTRAINT band_creation_past CHECK (creationDate < now());

ALTER TABLE ONLY band
    ADD CONSTRAINT band_location_fkey FOREIGN KEY (location) REFERENCES city(id) ON UPDATE CASCADE;

/*****************************************************/
/***************** Content ***************************/
/*****************************************************/


CREATE TABLE content (

    id SERIAL NOT NULL,
    text TEXT NOT NULL,
    date TIMESTAMP DEFAULT now(),
    isActive BOOLEAN DEFAULT TRUE

);

ALTER TABLE ONLY content
    ADD CONSTRAINT content_pkey PRIMARY KEY (id);


/*****************************************************/
/***************** Post ******************************/
/*****************************************************/


CREATE TABLE post (

    id SERIAL NOT NULL,
    private BOOLEAN NOT NULL DEFAULT FALSE,
    contentId INTEGER NOT NULL,
    posterId INTEGER NOT NULL,
    bandId INTEGER
);

ALTER TABLE ONLY post
    ADD CONSTRAINT post_pkey PRIMARY KEY (id);

ALTER TABLE ONLY post
    ADD CONSTRAINT post_content_id_fkey FOREIGN KEY (contentId) REFERENCES content(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY post
    ADD CONSTRAINT poster_id_fkey FOREIGN KEY (posterId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY post
    ADD CONSTRAINT post_band_id_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;


CREATE FUNCTION check_band_post() RETURNS trigger AS $check_band_post$
    BEGIN
       
        IF NEW.bandId IS NOT NULL THEN

            IF check_user_belongs_to_band(New.posterId, New.bandId) = FALSE THEN

                RAISE EXCEPTION 'this user does not belong to the band, post not inserted';

            END IF;

        END IF;

    
        RETURN NEW;

    END;
    
$check_band_post$ LANGUAGE plpgsql;

CREATE TRIGGER check_band_post BEFORE INSERT OR UPDATE ON post
    FOR EACH ROW EXECUTE PROCEDURE check_band_post();

/*****************************************************/
/***************** Message ***************************/
/*****************************************************/


CREATE TABLE message (

    id SERIAL NOT NULL,
    contentId INTEGER NOT NULL,
    senderId INTEGER NOT NULL,
    receiverId INTEGER,
    bandId INTEGER
);

ALTER TABLE ONLY message
    ADD CONSTRAINT message_pkey PRIMARY KEY (id);

ALTER TABLE ONLY message
    ADD CONSTRAINT message_content_id_fkey FOREIGN KEY (contentId) REFERENCES content(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY message
    ADD CONSTRAINT message_sender_id_fkey FOREIGN KEY (senderId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY message
    ADD CONSTRAINT message_receiver_id_fkey FOREIGN KEY (receiverId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY message
    ADD CONSTRAINT message_band_id_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;


CREATE FUNCTION check_user_belongs_to_band(userIdToCheck Integer, bandIdToCheck Integer) RETURNS BOOLEAN AS $$
    
    DECLARE result BOOLEAN;

    BEGIN
       
        SELECT EXISTS (SELECT band.id FROM band JOIN band_membership ON band.id = band_membership.bandId WHERE band.id = bandIdToCheck AND band_membership.userId = userIdToCheck) INTO result;
        
        RETURN result;

    END;

$$ LANGUAGE plpgsql;


CREATE FUNCTION check_band_message() RETURNS trigger AS $check_band_message$
    BEGIN
       
        IF NEW.bandId IS NOT NULL THEN

            IF check_user_belongs_to_band(New.senderId, New.bandId) = FALSE THEN

                RAISE EXCEPTION 'this user does not belong to the band';

            END IF;

        END IF;

    
        RETURN NEW;

    END;

$check_band_message$ LANGUAGE plpgsql;

CREATE TRIGGER check_band_message BEFORE INSERT OR UPDATE ON message
    FOR EACH ROW EXECUTE PROCEDURE check_band_message();


CREATE FUNCTION check_xor_message_destination() RETURNS trigger AS $check_xor_message_destination$
    BEGIN
        
        IF NEW.receiverId IS NULL AND NEW.bandId IS NULL THEN
            RAISE EXCEPTION 'receiverId and bandId cannot be both null';
        END IF;

        IF NEW.receiverId IS NOT NULL AND NEW.bandId IS NOT NULL THEN
            RAISE EXCEPTION 'receiverId and bandId cannot be both not null (%,%)', NEW.receiverId, New.bandId;
        END IF;

        RETURN NEW;

    END;
$check_xor_message_destination$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_message_destination BEFORE INSERT OR UPDATE ON message
    FOR EACH ROW EXECUTE PROCEDURE check_xor_message_destination();


CREATE FUNCTION insert_notification_trigger_message() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originMessage) VALUES('message',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_message AFTER INSERT ON message
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_message();



/*****************************************************/
/***************** Comment ***************************/
/*****************************************************/


CREATE TABLE comment (

    id SERIAL NOT NULL,
    contentId INTEGER NOT NULL,
    commenterId INTEGER NOT NULL,
    postId INTEGER NOT NULL
);

ALTER TABLE ONLY comment
    ADD CONSTRAINT comment_pkey PRIMARY KEY (id);

ALTER TABLE ONLY comment
    ADD CONSTRAINT comment_content_id_fkey FOREIGN KEY (contentId) REFERENCES content(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY comment
    ADD CONSTRAINT commenter_id_fkey FOREIGN KEY (commenterId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY comment
    ADD CONSTRAINT post_id_fkey FOREIGN KEY (postId) REFERENCES post(id) ON UPDATE CASCADE ON DELETE CASCADE;


CREATE OR REPLACE FUNCTION insert_notification_trigger_comment() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originComment) VALUES('comment',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_comment AFTER INSERT ON comment
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_comment();

/*****************************************************/
/***************** Genre *****************************/
/*****************************************************/



CREATE TABLE genre (

    id SERIAL NOT NULL,
    name TEXT NOT NULL,
    creatingAdminId INTEGER,
    isActive BOOLEAN DEFAULT TRUE

);

ALTER TABLE ONLY genre
    ADD CONSTRAINT genre_pkey PRIMARY KEY (id);

ALTER TABLE ONLY genre
    ADD CONSTRAINT genre_name_unique UNIQUE (name);

ALTER TABLE ONLY genre
    ADD CONSTRAINT genre_creatingAdmin_id_fkey FOREIGN KEY (creatingAdminId) REFERENCES mb_user(id) ON UPDATE CASCADE ON DELETE SET NULL;

CREATE FUNCTION check_is_admin_genre() RETURNS trigger AS $check_is_admin_genre$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.creatingAdminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_genre$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_genre BEFORE INSERT OR UPDATE ON genre
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_genre();


/*****************************************************/
/***************** Skill *****************************/
/*****************************************************/

CREATE TABLE skill (

    id SERIAL NOT NULL,
    name TEXT NOT NULL,
    creatingAdminId INTEGER,
    isActive BOOLEAN DEFAULT TRUE
);

ALTER TABLE ONLY skill
    ADD CONSTRAINT skill_pkey PRIMARY KEY (id);

ALTER TABLE ONLY skill
    ADD CONSTRAINT skill_name_unique UNIQUE (name);

ALTER TABLE ONLY skill
    ADD CONSTRAINT skill_creatingAdmin_id_fkey FOREIGN KEY (creatingAdminId) REFERENCES mb_user(id) ON UPDATE CASCADE ON DELETE SET NULL;

CREATE FUNCTION check_is_admin_skill() RETURNS trigger AS $check_is_admin_skill$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.creatingAdminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_skill$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_skill BEFORE INSERT OR UPDATE ON skill
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_skill();

/*****************************************************/
/***************** Report ****************************/
/*****************************************************/


CREATE TYPE REPORT_TYPE AS ENUM ('user_report', 'band_report', 'content_report');

CREATE TABLE report (

    id SERIAL NOT NULL,
    text TEXT NOT NULL,
    date TIMESTAMP DEFAULT now(),
    reportType REPORT_TYPE NOT NULL,
    reportedContentId INTEGER,
    reportedUserId INTEGER,
    reportedBandId INTEGER,
    reporterUserId INTEGER
);

ALTER TABLE ONLY report
    ADD CONSTRAINT report_pkey PRIMARY KEY (id);

ALTER TABLE ONLY report
    ADD CONSTRAINT reported_content_id_fkey FOREIGN KEY (reportedContentId) REFERENCES content(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY report
    ADD CONSTRAINT reported_user_id_fkey FOREIGN KEY (reportedUserId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY report
    ADD CONSTRAINT reported_band_id_fkey FOREIGN KEY (reportedBandId) REFERENCES band(id) ON UPDATE CASCADE;

ALTER TABLE ONLY report
    ADD CONSTRAINT reporter_user_id_fkey FOREIGN KEY (reporterUserId) REFERENCES mb_user(id) ON UPDATE CASCADE;


CREATE FUNCTION check_xor_report_type() RETURNS trigger AS $check_xor_report_type$
    BEGIN
        --Check for correct type
        IF NEW.reportType = 'user_report' AND NEW.reportedUserId IS NULL THEN
            RAISE EXCEPTION 'type user_report without reportedUserId';
        END IF;

        IF NEW.reportType = 'band_report' AND NEW.reportedBandId IS NULL THEN
            RAISE EXCEPTION 'type user_report without reportedBandId';
        END IF;

        IF NEW.reportType = 'content_report' AND NEW.reporterUserId IS NULL THEN
            RAISE EXCEPTION 'type user_report without reporterUserId';
        END IF;

        RETURN NEW;

    END;
$check_xor_report_type$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_report_type BEFORE INSERT OR UPDATE ON report
    FOR EACH ROW EXECUTE PROCEDURE check_xor_report_type();

    


/*****************************************************/
/******************* Ban *****************************/
/*****************************************************/



CREATE TABLE ban (

    id SERIAL NOT NULL,
    reason TEXT NOT NULL,
    banDate TIMESTAMP DEFAULT now(),
    ceaseDate TIMESTAMP,
    adminId INTEGER,
    userId INTEGER,
    bandId INTEGER
);

ALTER TABLE ONLY ban
    ADD CONSTRAINT ban_pkey PRIMARY KEY (id);

ALTER TABLE ONLY ban
    ADD CONSTRAINT admin_id_fkey FOREIGN KEY (adminId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY ban
    ADD CONSTRAINT band_id_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;

ALTER TABLE ONLY ban
    ADD CONSTRAINT user_id_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

CREATE FUNCTION check_is_admin_ban() RETURNS trigger AS $check_is_admin_ban$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.adminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_ban$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_ban BEFORE INSERT OR UPDATE ON ban
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_ban();

CREATE FUNCTION check_xor_user_band() RETURNS trigger AS $check_xor_user_band$
    BEGIN
        --Check if both user and ban are empty--
        IF NEW.userId IS NULL AND NEW.bandId IS NULL THEN
            RAISE EXCEPTION 'userId and bandId cannot be both null';
        END IF;

        --Check if both are not null
        IF NEW.userId IS NOT NULL AND NEW.bandId IS NOT NULL THEN
            RAISE EXCEPTION 'userId and bandId cannot be both not null (%,%)', NEW.userId, New.bandId;
        END IF;

        RETURN NEW;

    END;
$check_xor_user_band$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_user_band BEFORE INSERT OR UPDATE ON ban
    FOR EACH ROW EXECUTE PROCEDURE check_xor_user_band();



/*****************************************************/
/******************* User Skill **********************/
/*****************************************************/



CREATE TABLE user_skill (

    userId INTEGER NOT NULL,
    skillId INTEGER NOT NULL,
    level INTEGER NOT NULL,
    isActive BOOLEAN DEFAULT TRUE

);

ALTER TABLE ONLY user_skill
    ADD CONSTRAINT user_skill_pkey PRIMARY KEY (userId,skillId);

ALTER TABLE ONLY user_skill
    ADD CONSTRAINT userId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY user_skill
    ADD CONSTRAINT skillId_fkey FOREIGN KEY (skillId) REFERENCES skill(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY user_skill
    ADD CONSTRAINT user_skill_level_domain CHECK ((level <= 5) AND (level >= 1));


/*****************************************************/
/******************* User Follower *******************/
/*****************************************************/



CREATE TABLE user_follower (

    id SERIAL NOT NULL,
    followingUserId INTEGER NOT NULL,
    followedUserId INTEGER NOT NULL,
    isActive BOOLEAN DEFAULT TRUE

);

ALTER TABLE ONLY user_follower
    ADD CONSTRAINT user_follower_pkey PRIMARY KEY (id);

ALTER TABLE ONLY user_follower
    ADD CONSTRAINT user_follower_unique_pair UNIQUE (followingUserId,followedUserId);

ALTER TABLE ONLY user_follower
    ADD CONSTRAINT followingUserId_fkey FOREIGN KEY (followingUserId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY user_follower
    ADD CONSTRAINT followedUserId_fkey FOREIGN KEY (followedUserId) REFERENCES mb_user(id) ON UPDATE CASCADE;


CREATE FUNCTION insert_notification_trigger_user_follower() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originUserFollower) VALUES('user_follower',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_user_follower AFTER INSERT ON user_follower
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_user_follower();


/*****************************************************/
/******************* User Rating *********************/
/*****************************************************/



CREATE TABLE user_rating (

    ratingUserid INTEGER NOT NULL,
    ratedUserId INTEGER NOT NULL,
    rate INTEGER NOT NULL

);

ALTER TABLE ONLY user_rating
    ADD CONSTRAINT user_rating_pkey PRIMARY KEY (ratingUserid,ratedUserId);

ALTER TABLE ONLY user_rating
    ADD CONSTRAINT user_rating_rating_userId_fkey FOREIGN KEY (ratingUserid) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY user_rating
    ADD CONSTRAINT user_rating_rated_userId_fkey FOREIGN KEY (ratedUserId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY user_rating
    ADD CONSTRAINT user_rating_rate_domain CHECK ((rate <= 5) AND (rate >= 1));

/*****************************************************/
/******************* User Warning ********************/
/*****************************************************/



CREATE TABLE user_warning (

    id SERIAL NOT NULL,
    adminId INTEGER NOT NULL,
    userId INTEGER NOT NULL

);

ALTER TABLE ONLY user_warning
    ADD CONSTRAINT user_warning_pkey PRIMARY KEY (id);

ALTER TABLE ONLY user_warning
    ADD CONSTRAINT user_warning_adminId_fkey FOREIGN KEY (adminId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY user_warning
    ADD CONSTRAINT user_warning_userId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

CREATE FUNCTION check_is_admin_user_warning() RETURNS trigger AS $check_is_admin_user_warning$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.adminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_user_warning$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_user_warning BEFORE INSERT OR UPDATE ON user_warning
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_user_warning();


CREATE OR REPLACE FUNCTION insert_notification_trigger_user_warning() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originUserWarning) VALUES('user_warning',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_user_warning AFTER INSERT ON user_warning
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_user_warning();

/*****************************************************/
/******************* Band Genre **********************/
/*****************************************************/



CREATE TABLE band_genre (

    bandId INTEGER NOT NULL,
    genreId INTEGER NOT NULL,
    isActive BOOLEAN DEFAULT TRUE
);

ALTER TABLE ONLY band_genre
    ADD CONSTRAINT band_genre_pkey PRIMARY KEY (bandId,genreId);

ALTER TABLE ONLY band_genre
    ADD CONSTRAINT band_genre_bandId_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_genre
    ADD CONSTRAINT band_genre_genreId_fkey FOREIGN KEY (genreId) REFERENCES genre(id) ON UPDATE CASCADE ON DELETE CASCADE;

/*****************************************************/
/******************* Band Membership *****************/
/*****************************************************/


CREATE TABLE band_membership (

    id SERIAL NOT NULL,
    bandId INTEGER NOT NULL,
    userId INTEGER NOT NULL,
    isOwner BOOLEAN NOT NULL,
    initialDate DATE DEFAULT now(),
    ceaseDate DATE
);

ALTER TABLE ONLY band_membership
    ADD CONSTRAINT band_membership_pkey PRIMARY KEY (id);

ALTER TABLE ONLY band_membership
    ADD CONSTRAINT band_membership_bandId_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_membership
    ADD CONSTRAINT band_membership_userId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;


/*****************************************************/
/******************* Band Rating *********************/
/*****************************************************/


CREATE TABLE band_rating (

    ratingUserid INTEGER NOT NULL,
    ratedBandId INTEGER NOT NULL,
    rate INTEGER NOT NULL

);

ALTER TABLE ONLY band_rating
    ADD CONSTRAINT band_rating_pkey PRIMARY KEY (ratingUserid,ratedBandId);

ALTER TABLE ONLY band_rating
    ADD CONSTRAINT band_rating_rating_userId_fkey FOREIGN KEY (ratingUserid) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_rating
    ADD CONSTRAINT band_rating_rated_bandId_fkey FOREIGN KEY (ratedBandId) REFERENCES band(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_rating
    ADD CONSTRAINT band_rating_rate_domain CHECK ((rate <= 5) AND (rate >= 1));


/*****************************************************/
/******************* Band Warning ********************/
/*****************************************************/


CREATE TABLE band_warning (

    id SERIAL NOT NULL,
    adminId INTEGER NOT NULL,
    bandId INTEGER NOT NULL

);

ALTER TABLE ONLY band_warning
    ADD CONSTRAINT band_warning_pkey PRIMARY KEY (id);

ALTER TABLE ONLY band_warning
    ADD CONSTRAINT band_warning_adminId_fkey FOREIGN KEY (adminId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_warning
    ADD CONSTRAINT band_warning_userId_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;

CREATE FUNCTION check_is_admin_band_warning() RETURNS trigger AS $check_is_admin_band_warning$
    BEGIN
        --Check if user is an admin--
        IF NOT is_admin(NEW.adminId) THEN
            RAISE EXCEPTION 'User is not an Admin';
        END IF;

        RETURN NEW;

    END;
$check_is_admin_band_warning$ LANGUAGE plpgsql;

CREATE TRIGGER check_is_admin_band_warning BEFORE INSERT OR UPDATE ON band_warning
    FOR EACH ROW EXECUTE PROCEDURE check_is_admin_band_warning();


CREATE OR REPLACE FUNCTION insert_notification_trigger_band_warning() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandWarning) VALUES('band_warning',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_warning AFTER INSERT ON band_warning
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_warning();


/*****************************************************/
/******************* Band Follower *******************/
/*****************************************************/



CREATE TABLE band_follower (

    id SERIAL NOT NULL,
    userId INTEGER NOT NULL,
    bandId INTEGER NOT NULL,
    isActive BOOLEAN DEFAULT TRUE

);

ALTER TABLE ONLY band_follower
    ADD CONSTRAINT band_follower_pkey PRIMARY KEY (id);

ALTER TABLE ONLY band_follower
    ADD CONSTRAINT band_follower_unique_pair UNIQUE (userId,bandId);

ALTER TABLE ONLY band_follower
    ADD CONSTRAINT followingUserId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_follower
    ADD CONSTRAINT followedBandId_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;


CREATE FUNCTION insert_notification_trigger_band_follower() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandFollower) VALUES('band_follower',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_follower AFTER INSERT ON band_follower
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_follower();


/*****************************************************/
/******************* Band Application ****************/
/*****************************************************/



CREATE TYPE BAND_APPLICATION_STATUS AS ENUM ('canceled', 'pending', 'accepted', 'rejected');

CREATE TABLE band_application (

    id SERIAL NOT NULL,
    userId INTEGER NOT NULL,
    bandId INTEGER NOT NULL,
    date TIMESTAMP DEFAULT now(),
    lastStatusDate DATE,
    status BAND_APPLICATION_STATUS DEFAULT 'pending'

);

ALTER TABLE ONLY band_application
    ADD CONSTRAINT band_application_pkey PRIMARY KEY (id);

ALTER TABLE ONLY band_application
    ADD CONSTRAINT band_application_userId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_application
    ADD CONSTRAINT band_application_bandId_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;


CREATE OR REPLACE FUNCTION insert_notification_trigger_band_application() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandApplication) VALUES('band_application',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_application AFTER INSERT ON band_application
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_application();

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_application_accepted() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'accepted' THEN
            INSERT INTO notification_trigger(type,originBandApplication) VALUES('band_application_accepted',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_application_accepted AFTER UPDATE ON band_application
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_application_accepted();

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_application_rejected() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'rejected' THEN
            INSERT INTO notification_trigger(type,originBandApplication) VALUES('band_application_rejected',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_application_rejected AFTER UPDATE ON band_application
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_application_rejected();

/*****************************************************/
/******************* Band Invitation *****************/
/*****************************************************/



CREATE TYPE BAND_INVITATION_STATUS AS ENUM ('canceled', 'pending', 'accepted', 'rejected');

CREATE TABLE band_invitation(

    id SERIAL NOT NULL,
    userId INTEGER NOT NULL,
    bandId INTEGER NOT NULL,
    date TIMESTAMP DEFAULT now(),
    lastStatusDate DATE,
    status BAND_INVITATION_STATUS DEFAULT 'pending'

);

ALTER TABLE ONLY band_invitation
    ADD CONSTRAINT band_invitation_pkey PRIMARY KEY (id);

ALTER TABLE ONLY band_invitation
    ADD CONSTRAINT band_invitation_userId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

ALTER TABLE ONLY band_invitation
    ADD CONSTRAINT band_invitation_bandId_fkey FOREIGN KEY (bandId) REFERENCES band(id) ON UPDATE CASCADE;

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_invitation() RETURNS trigger AS $$
    BEGIN
       
        INSERT INTO notification_trigger(type,originBandInvitation) VALUES('band_invitation',New.id);
        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_invitation AFTER INSERT ON band_invitation
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_invitation();

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_invitation_accepted() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'accepted' THEN
            INSERT INTO notification_trigger(type,originBandInvitation) VALUES('band_invitation_accepted',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_invitation_accepted AFTER UPDATE ON band_invitation
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_invitation_accepted();

CREATE OR REPLACE FUNCTION insert_notification_trigger_band_invitation_rejected() RETURNS trigger AS $$
    BEGIN
       
        IF NEW.status = 'rejected' THEN
            INSERT INTO notification_trigger(type,originBandInvitation) VALUES('band_invitation_rejected',New.id);
        END IF;

        RETURN NEW;

    END;
    
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_notification_trigger_band_invitation_rejected AFTER UPDATE ON band_invitation
    FOR EACH ROW EXECUTE PROCEDURE insert_notification_trigger_band_invitation_rejected();

/*****************************************************/
/************ Notification Trigger *******************/
/*****************************************************/



CREATE TYPE NOTIFICATION_TYPE AS ENUM (
    'user_follower', 'band_follower', 'message', 'comment', 'band_application',
    'band_invitation', 'user_warning', 'band_warning', 'band_invitation_accepted',
    'band_invitation_rejected', 'band_application_accepted', 'band_application_rejected');

CREATE TABLE notification_trigger (

    id SERIAL NOT NULL,
    date TIMESTAMP NOT NULL DEFAULT now(),
    type NOTIFICATION_TYPE NOT NULL,
    originUserFollower INTEGER,
    originBandFollower INTEGER,
    originMessage INTEGER,
    originComment INTEGER,
    originBandApplication INTEGER,
    originBandInvitation INTEGER,
    originUserWarning INTEGER,
    originBandWarning INTEGER
);

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_pkey PRIMARY KEY (id);

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_user_follower_fkey FOREIGN KEY (originUserFollower) REFERENCES user_follower(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_band_follower_fkey FOREIGN KEY (originBandFollower) REFERENCES band_follower(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_message_fkey FOREIGN KEY (originMessage) REFERENCES message(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_comment_fkey FOREIGN KEY (originComment) REFERENCES comment(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_band_application_fkey FOREIGN KEY (originBandApplication) REFERENCES band_application(id) ON UPDATE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_band_invitation_fkey FOREIGN KEY (originBandInvitation) REFERENCES band_invitation(id) ON UPDATE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_user_warning_fkey FOREIGN KEY (originUserWarning) REFERENCES user_warning(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY notification_trigger
    ADD CONSTRAINT notification_trigger_origin_band_warning_fkey FOREIGN KEY (originBandWarning) REFERENCES band_warning(id) ON UPDATE CASCADE ON DELETE CASCADE;


CREATE FUNCTION check_xor_notification_origin() RETURNS trigger AS $check_xor_notification_origin$
    BEGIN

        --Check for correct type and origin
        IF NEW.type = 'user_follower' AND NEW.originUserFollower IS NULL THEN
            RAISE EXCEPTION 'type user follower without originUserFollowerId';
        END IF;

        IF NEW.type = 'band_follower' AND NEW.originBandFollower IS NULL THEN
            RAISE EXCEPTION 'type band follower without bandFollowerId';
        END IF;

        IF NEW.type = 'message' AND NEW.originMessage IS NULL THEN
            RAISE EXCEPTION 'type message without originMessageId';
        END IF;

        IF NEW.type = 'comment' AND NEW.originComment IS NULL THEN
            RAISE EXCEPTION 'type comment without originCommentId';
        END IF;

        IF NEW.type = 'band_application' AND NEW.originBandApplication IS NULL THEN
            RAISE EXCEPTION 'type band application without originBandApplicationId';
        END IF;

        IF NEW.type = 'band_invitation' AND NEW.originBandInvitation IS NULL THEN
            RAISE EXCEPTION 'type band invitation without band invitation Id';
        END IF;

        IF NEW.type = 'user_warning' AND NEW.originUserWarning IS NULL THEN
            RAISE EXCEPTION 'type user warning without origin user warning id';
        END IF;

        IF NEW.TYPE = 'band_warning' AND NEW.originBandWarning IS NULL THEN
            RAISE EXCEPTION 'type band warning without band warning Id';
        END IF;

        IF NEW.TYPE = 'band_invitation_accepted' AND NEW.originBandInvitation IS NULL THEN
            RAISE EXCEPTION 'type band invitation accepted without band inivitation Id';
        END IF;

         IF NEW.TYPE = 'band_invitation_rejected' AND NEW.originBandInvitation IS NULL THEN
            RAISE EXCEPTION 'type band invitation rejected without band inivitation Id';
        END IF;

        IF NEW.TYPE = 'band_application_accepted' AND NEW.originBandApplication IS NULL THEN
            RAISE EXCEPTION 'type band application accepted without band application Id';
        END IF;

        IF NEW.TYPE = 'band_application_rejected' AND NEW.originBandApplication IS NULL THEN
            RAISE EXCEPTION 'type band application accepted without band application Id';
        END IF;

        RETURN NEW;

    END;
$check_xor_notification_origin$ LANGUAGE plpgsql;

CREATE TRIGGER check_xor_notification_origin BEFORE INSERT OR UPDATE ON notification_trigger
    FOR EACH ROW EXECUTE PROCEDURE check_xor_notification_origin();


CREATE OR REPLACE FUNCTION send_notification_to_band(notifBandId INTEGER, notifTriggerId INTEGER, notifText TEXT)
RETURNS VOID AS $$
    DECLARE
        receiverId INTEGER;
    BEGIN
        FOR receiverId IN 
            SELECT band_membership.userId
            FROM band_membership 
            WHERE band_membership.bandId = notifBandId 
        LOOP
            INSERT INTO user_notification(notificationTriggerId, userId, text) VALUES(notifTriggerId, receiverId, notifText);
        END LOOP;
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insert_user_notifications_user_follower(notifTriggerId INTEGER, userFollowerId INTEGER)
RETURNS VOID AS $$
    DECLARE
        receiverId INTEGER;
        senderName TEXT;
        notifText TEXT;
    BEGIN
        SELECT followedUserId, mb_user.name INTO receiverId, senderName
        FROM user_follower JOIN mb_user
        ON mb_user.id = user_follower.followingUserId
        WHERE user_follower.id = userFollowerId;

        notifText := senderName || ' started to follow you!';

        INSERT INTO user_notification(notificationTriggerId, userId, text) VALUES(notifTriggerId, receiverId, notifText);
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insert_user_notifications_band_follower(notifTriggerId INTEGER, bandFollowerId INTEGER)
RETURNS VOID AS $$
    DECLARE
        senderName TEXT;
        bandName TEXT;
        notifText TEXT;
        declaredBandId INTEGER;
    BEGIN

        SELECT mb_user.name, band.name INTO senderName, bandName
        FROM band_follower 
        JOIN mb_user ON band_follower.userId = mb_user.id
        JOIN band ON band.id = band_follower.bandId
        WHERE band_follower.id = bandFollowerId;

        notifText := senderName || ' started to follow ' || bandName || '!';
        
        SELECT band_follower.bandId INTO declaredBandId FROM band_follower WHERE band_follower.id = bandFollowerId;

        PERFORM send_notification_to_band(declaredBandId, notifTriggerId, notifText);

    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insert_user_notifications_message(notifTriggerId INTEGER, messageId INTEGER)
RETURNS VOID AS $$
    DECLARE
        vReceiverId INTEGER;
        vBandId INTEGER;
        vSenderId INTEGER;
        vSenderName TEXT;
        vNotifText TEXT;
    BEGIN
        SELECT message.receiverId, message.bandId, mb_user.name, content.text 
        INTO vReceiverId, vBandId, vSenderName, vNotifText 
        FROM message
        JOIN mb_user ON mb_user.id = message.senderId
        JOIN content ON content.id = message.contentId
        WHERE message.id = messageId;

        CASE
            WHEN vReceiverId IS NOT NULL THEN
                INSERT INTO user_notification(notificationTriggerId, userId, text) VALUES(notifTriggerId, vReceiverId, vNotifText);
            WHEN vBandId IS NOT NULL THEN
                PERFORM send_notification_to_band(vBandId, notifTriggerId, vNotifText);
            ELSE
                RAISE EXCEPTION 'Receiver message invalid';
        END CASE;

    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insert_user_notifications_comment(notifTriggerId INTEGER, commentId INTEGER)
RETURNS VOID AS $$
    DECLARE
        vPosterId INTEGER;
        vBandId INTEGER;
        vCommenterId INTEGER;
        vCommenterName TEXT;
        vNotifText TEXT;
        vCommentText TEXT;
    BEGIN
        SELECT post.posterId, post.bandId, mb_user.name, content.text 
        INTO vPosterId, vBandId, vCommenterName, vCommentText 
        FROM comment
        JOIN post ON post.id = comment.postId
        JOIN mb_user ON mb_user.id = comment.commenterId
        JOIN content ON content.id = comment.contentId
        WHERE comment.id = commentId;

        vNotifText := vCommenterName || ' commented your post: ' + vCommentText;
        CASE
            WHEN vBandId IS NOT NULL THEN
                PERFORM send_notification_to_band(vBandId, notifTriggerId, vNotifText);
            ELSE
                INSERT INTO user_notification(notificationTriggerId, userId, text) VALUES(notifTriggerId, vPosterId, vNotifText);
        END CASE;

    END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION trigger_user_notifications() RETURNS TRIGGER AS $$
    BEGIN
        CASE New.type
            WHEN 'user_follower' THEN
                PERFORM insert_user_notifications_user_follower(New.id, New.originUserFollower);
            WHEN 'band_follower' THEN
                PERFORM insert_user_notifications_band_follower(New.id, New.originBandFollower);
            WHEN 'message' THEN
                PERFORM insert_user_notifications_message(New.id, New.originMessage);
            WHEN 'comment' THEN
                PERFORM insert_user_notifications_comment(New.id, New.originComment);
            ELSE
                RAISE EXCEPTION 'Notification type invalid';
        END CASE;

        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_user_notifications AFTER INSERT ON notification_trigger
    FOR EACH ROW EXECUTE PROCEDURE trigger_user_notifications();

/*****************************************************/
/*************** User Notification *******************/
/*****************************************************/



CREATE TABLE user_notification (

    notificationTriggerId INTEGER NOT NULL,
    userId INTEGER NOT NULL,
    visualizedDate DATE,
    text TEXT
);

ALTER TABLE ONLY user_notification
    ADD CONSTRAINT user_notification_pkey PRIMARY KEY (notificationTriggerId, userId);

ALTER TABLE ONLY user_notification
    ADD CONSTRAINT user_notification_notification_trigger_fkey FOREIGN KEY (notificationTriggerId) REFERENCES notification_trigger(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY user_notification
    ADD CONSTRAINT user_notification_userId_fkey FOREIGN KEY (userId) REFERENCES mb_user(id) ON UPDATE CASCADE;

```

## Revision history

***

GROUP1712, 4/04/2018

> João Pinheiro, up201104913@fe.up.pt

> Leonardo Teixeira, up201502848@fe.up.pt

> Danny Soares, up201505509@fe.up.pt

> João Azevedo, up201503256@fe.up.pt    |
